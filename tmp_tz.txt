    const isoString = `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}:${parts.second}.000Z`;
    const tzAsUTC = new Date(isoString);
    const offsetMinutes = Math.round((tzAsUTC.getTime() - referenceDate.getTime()) / 60000);
    return offsetMinutes;
  } catch (error) {
    return 0;
  }
};

const formatTimeZoneOffset = (timeZone, referenceDate = new Date()) => {
  try {
    const offsetMinutes = getTimeZoneOffsetMinutes(timeZone, referenceDate);
    const sign = offsetMinutes >= 0 ? '+' : '-';
    const absMinutes = Math.abs(offsetMinutes);
    const hours = String(Math.floor(absMinutes / 60)).padStart(2, '0');
    const minutes = String(absMinutes % 60).padStart(2, '0');
    return `(UTC${sign}${hours}:${minutes})`;
  } catch (error) {
    return '(UTC+00:00)';
  }
};

const buildTimeZoneLabel = (timeZone, referenceDate) => {
  const offset = formatTimeZoneOffset(timeZone, referenceDate);
  const cityName = extractCityName(timeZone);
  const overrideName = TIMEZONE_NAME_OVERRIDES[timeZone];
  const baseName = overrideName || cityName || timeZone;
  // Append English city name when available to keep clarity
  const suffix = overrideName && cityName && overrideName !== cityName ? ` - ${cityName}` : '';
  return `${offset} ${baseName}${suffix}`;
};

const getDefaultTimeZone = () => {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone || 'Asia/Shanghai';
  } catch (error) {
    return 'Asia/Shanghai';
  }
};

const buildTimeZoneOptions = (referenceDate = new Date()) => {
  // Only show curated 24 time zones to keep the list clean and simple
  return FALLBACK_TIMEZONES.map((timeZone) => ({
    value: timeZone,
    label: buildTimeZoneLabel(timeZone, referenceDate),
  }));
};

// Order options so that:
// - time zones later than the selected are listed first (above),
// - selected time zone in the middle,
// - earlier time zones listed after (below).
const orderTimeZoneOptionsAroundSelected = (options, selectedValue, referenceDate = new Date()) => {
  if (!selectedValue) return options;
  const decorated = options.map((o) => ({
    ...o,
    _offset: getTimeZoneOffsetMinutes(o.value, referenceDate),
  }));
  const selectedOffset = getTimeZoneOffsetMinutes(selectedValue, referenceDate);

  const later = decorated.filter((o) => o._offset > selectedOffset).sort((a, b) => b._offset - a._offset);
  const earlier = decorated.filter((o) => o._offset < selectedOffset).sort((a, b) => b._offset - a._offset);

  const selectedInList = decorated.find((o) => o.value === selectedValue);
  const selectedOption =
    selectedInList || {
      value: selectedValue,
      label: buildTimeZoneLabel(selectedValue, referenceDate),
      _offset: selectedOffset,
    };

  const result = [...later, selectedOption, ...earlier].map(({ _offset, ...rest }) => rest);
  // Deduplicate by value in case selected already existed
  const seen = new Set();
  return result.filter((o) => {
    if (seen.has(o.value)) return false;
    seen.add(o.value);
    return true;
  });
};

