import React, { useMemo, useState, useEffect, useRef, lazy, Suspense, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import './StudentCourseRequestPage.css';
import BrandMark from '../../components/common/BrandMark/BrandMark';
import {
  FaCode,
  FaProjectDiagram,
  FaCalculator,
  FaChartPie,
  FaRobot,
  FaAtom,
  FaChartBar,
  FaDollarSign,
  FaFileAlt,
  FaEllipsisH,
  FaBullhorn,
  FaCogs,
  FaBalanceScale,
  FaLaptopCode,
  FaShieldAlt,
  FaUniversity,
  FaTasks,
  FaUserTie,
  FaDna,
  FaFlask,
  FaCubes,
  FaPalette,
  FaLanguage,
  FaBrain,
  FaBroadcastTower,
  FaGlobe,
  FaClock,
  FaCalendarAlt,
  FaHeart,
  FaLightbulb,
  FaGraduationCap,
  FaImages,
} from 'react-icons/fa';
import { RiAiGenerate, RiDeleteBin6Line } from 'react-icons/ri';

const EMPTY_BLOCKS = [];

export const ScheduleTimesPanel = React.memo(function ScheduleTimesPanel({
  value,                 // 当前小时数
  onChange,              // (next:number) => void
  listRef,               // 传入你原来的 timesListRef
  min = 0.25,
  max = 6,
  step = 0.25,
  // 受控：当外部需要按“天”管理选择时传入
  blocks,                // 可选，形如 [{start:number,end:number}]
  onBlocksChange,        // 可选，(nextBlocks) => void
  dayKey,                // 可选，'YYYY-MM-DD' 当前天 key
  getDayBlocks,          // 可选，(key)=>blocks，用于跨天读
  setDayBlocks,          // 可选，(key,next)=>void，用于跨天写
}) {
  const valueRef = useRef(value);
  useEffect(() => { valueRef.current = value; }, [value]);
  // ―― 工具 & 边界 ―― //

  const ensureQuarter = useCallback((raw) => {
    const n = parseFloat(raw);
    if (!isFinite(n)) return 2;
    const clamped = Math.max(min, Math.min(max, n));
    return Number((Math.round(clamped / 0.25) * 0.25).toFixed(2));
  }, [min, max]);

  const setValue = useCallback((v) => {
    onChange(ensureQuarter(v));
  }, [onChange, ensureQuarter]);

  const adjust = useCallback((delta) => {
    const cur = valueRef.current ?? 0;                   // 永远拿“最新值”
    // 单击时也做一次边界拦截（否则会出现点减号没反应的错觉）
    if ((delta < 0 && cur <= min) || (delta > 0 && cur >= max)) return;
    const next = ensureQuarter(cur + delta);
    onChange(next);
  }, [ensureQuarter, onChange, min, max]);

  // ―― 长按（全局收尾）―― //
  const HOLD_DELAY = 300, HOLD_INTERVAL = 150;
  const pressTimerRef = useRef(null);
  const repeatTimerRef = useRef(null);
  const isHoldingRef = useRef(false);
  const isPressedRef = useRef(false);
  const deltaRef = useRef(0);
  const endHandlerRef = useRef(null);

  const clearTimers = useCallback(() => {
    if (pressTimerRef.current) { clearTimeout(pressTimerRef.current); pressTimerRef.current = null; }
    if (repeatTimerRef.current) { clearInterval(repeatTimerRef.current); repeatTimerRef.current = null; }
    isHoldingRef.current = false;
    isPressedRef.current = false;
  }, []);

  const detachGlobal = useCallback(() => {
    const h = endHandlerRef.current;
    if (!h) return;
    window.removeEventListener('mouseup', h);
    window.removeEventListener('touchend', h);
    window.removeEventListener('touchcancel', h);
    window.removeEventListener('blur', h);
    endHandlerRef.current = null;
  }, []);

  const endGlobal = useCallback(() => {
    if (isPressedRef.current && !isHoldingRef.current) adjust(deltaRef.current); // 单击一步
    detachGlobal();
    clearTimers();
  }, [adjust, clearTimers, detachGlobal]);

  useEffect(() => () => { detachGlobal(); clearTimers(); }, [detachGlobal, clearTimers]);

  const startPress = useCallback((delta) => (e) => {
    if (e.currentTarget.disabled) return;
    e.preventDefault();
    isPressedRef.current = true;
    isHoldingRef.current = false;
    deltaRef.current = delta;

    endHandlerRef.current = endGlobal;
    window.addEventListener('mouseup', endGlobal);
    window.addEventListener('touchend', endGlobal, { passive: true });
    window.addEventListener('touchcancel', endGlobal, { passive: true });
    window.addEventListener('blur', endGlobal);

    pressTimerRef.current = setTimeout(() => {
      if (!isPressedRef.current) return;
      isHoldingRef.current = true;
      repeatTimerRef.current = setInterval(() => {
        const cur = ensureQuarter(valueRef.current ?? 0);
        if ((delta < 0 && cur <= min) || (delta > 0 && cur >= max)) {
          endGlobal();
          return;
        }
        adjust(delta);
      }, HOLD_INTERVAL);
    }, HOLD_DELAY);
  }, [adjust, endGlobal, ensureQuarter, min, max]);

  // ―― 时间列表（保持你的逻辑）―― //
  const formatTime = useCallback((h, m) => `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`, []);
  const timeSlots = useMemo(() => {
    const arr = [];
    for (let h = 0; h < 24; h++) for (let m = 0; m < 60; m += 15) arr.push({ h, m, label: formatTime(h, m) });
    return arr;
  }, [formatTime]);

  // 支持多段选择：受控/非受控两种模式
  const isControlledBlocks = Array.isArray(blocks) && typeof onBlocksChange === 'function';
  const [uncontrolledBlocks, setUncontrolledBlocks] = useState([]); // [{start,end}]
  const selectedBlocks = useMemo(
    () => (isControlledBlocks ? (blocks ?? EMPTY_BLOCKS) : uncontrolledBlocks),
    [isControlledBlocks, blocks, uncontrolledBlocks]
  );

  const applyBlocks = useCallback((next) => {
    if (isControlledBlocks) {
      onBlocksChange(next);
    } else {
      setUncontrolledBlocks(next);
    }
  }, [isControlledBlocks, onBlocksChange]);

  // 计算：当前“单次时长”换算成多少个 15 分钟格
  const slotsPerSession = useMemo(() => {
    const SLOT_MINUTES = 15;
    return Math.max(1, Math.round(((value ?? 0) * 60) / SLOT_MINUTES));
  }, [value]);

  // 合并重叠/相邻的区间，保证 selectedBlocks 始终为最简集合
  const mergeBlocks = useCallback((blocks) => {
    if (!blocks || !blocks.length) return [];
    const sorted = [...blocks]
      .map((b) => ({ start: Math.min(b.start, b.end), end: Math.max(b.start, b.end) }))
      .sort((a, b) => a.start - b.start);
    const merged = [sorted[0]];
    for (let i = 1; i < sorted.length; i++) {
      const prev = merged[merged.length - 1];
      const cur = sorted[i];
      if (cur.start <= prev.end + 1) {
        prev.end = Math.max(prev.end, cur.end);
      } else {
        merged.push({ ...cur });
      }
    }
    return merged;
  }, []);

  // 辅助：dayKey <-> Date 与相邻 day key
  const keyToDate = useCallback((key) => {
    if (!key) return null;
    const [y, m, d] = key.split('-').map((s) => parseInt(s, 10));
    if (!y || !m || !d) return null;
    return new Date(y, m - 1, d);
  }, []);
  const dateToKey = useCallback((date) => {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');
    return `${y}-${m}-${d}`;
  }, []);
  const neighborKey = useCallback((dir) => {
    // dir: +1 明天，-1 昨天
    const dt = keyToDate(dayKey);
    if (!dt) return null;
    const n = new Date(dt);
    n.setDate(dt.getDate() + (dir > 0 ? 1 : -1));
    return dateToKey(n);
  }, [dayKey, dateToKey, keyToDate]);

  const handleClickSlot = useCallback((idx) => {
    const len = timeSlots.length;
    const i = Math.max(0, Math.min(len - 1, idx));

    // 若当前索引已在某个已选区间内，则移除整个区间
    const containerIndex = (selectedBlocks || []).findIndex((b) => i >= b.start && i <= b.end);
    if (containerIndex >= 0) {
      const last = len - 1;
      const block = (selectedBlocks || [])[containerIndex];
      const next = (selectedBlocks || []).filter((_, k) => k !== containerIndex);
      applyBlocks(next);

      // 如果该段触及当天末尾且跨到下一天（即下一天0点起存在衔接段），连同下一天的首段一起删除
      if (block && block.end === last && typeof getDayBlocks === 'function' && typeof setDayBlocks === 'function') {
        const nxtKey = neighborKey(+1);
        const nxtBlocks = (getDayBlocks && nxtKey) ? (getDayBlocks(nxtKey) || []) : [];
        const idx0 = nxtBlocks.findIndex((b) => 0 >= b.start && 0 <= b.end);
        if (idx0 >= 0) {
          const after = nxtBlocks.filter((_, k) => k !== idx0);
          setDayBlocks(nxtKey, mergeBlocks(after));
        }
      }

      // 如果该段从 0 开始，且昨天结尾有一段与之衔接，也一并删除
      if (block && block.start === 0 && typeof getDayBlocks === 'function' && typeof setDayBlocks === 'function') {
        const prvKey = neighborKey(-1);
        const prvBlocks = (getDayBlocks && prvKey) ? (getDayBlocks(prvKey) || []) : [];
        const idxLast = prvBlocks.findIndex((b) => (len - 1) >= b.start && (len - 1) <= b.end);
        if (idxLast >= 0) {
          const afterPrev = prvBlocks.filter((_, k) => k !== idxLast);
          setDayBlocks(prvKey, mergeBlocks(afterPrev));
        }
      }
      return;
    }

    // 否则按当前“单次时长”新增区间并合并
    const start = i;
    const endWanted = i + slotsPerSession - 1; // 可能越过当天
    const last = len - 1;

    if (endWanted <= last) {
      const end = Math.max(0, Math.min(last, endWanted));
      const next = mergeBlocks([...(selectedBlocks || []), { start, end }]);
      applyBlocks(next);
    } else {
      // 当天部分
      const todayEnd = last;
      const nextToday = mergeBlocks([...(selectedBlocks || []), { start, end: todayEnd }]);
      applyBlocks(nextToday);

      // 溢出到明天的部分：从 0 开始若干格
      if (typeof getDayBlocks === 'function' && typeof setDayBlocks === 'function') {
        const overflowCount = endWanted - last; // 超出的格数
        const nxtKey = neighborKey(+1);
        if (nxtKey) {
          const nxtBlocks = getDayBlocks(nxtKey) || [];
          const nextNxt = mergeBlocks([...(nxtBlocks || []), { start: 0, end: Math.max(0, overflowCount - 1) }]);
          setDayBlocks(nxtKey, nextNxt);
        }
      }
    }
  }, [applyBlocks, getDayBlocks, setDayBlocks, mergeBlocks, neighborKey, selectedBlocks, slotsPerSession, timeSlots]);

  const selectedIndexSet = useMemo(() => {
    const set = new Set();
    for (const b of selectedBlocks) {
      for (let i = b.start; i <= b.end; i++) set.add(i);
    }
    return set;
  }, [selectedBlocks]);

  return (
    <div className="schedule-times-panel">
      <div className="times-panel-header">
        <div className="day-title">单次时长</div>
        <div className="duration-input">
          <button
            type="button"
            className="stepper-btn"
            aria-label="minus 0.25 hour"
            disabled={(value ?? 0) <= min}
            onMouseDown={startPress(-step)}
            onTouchStart={startPress(-step)}
            onContextMenu={(e) => e.preventDefault()}
          >
            <span aria-hidden>?</span>
          </button>

          <span className="duration-value" id="sessionDurationValue">{value}</span>

          <button
            type="button"
            className="stepper-btn"
            aria-label="plus 0.25 hour"
            disabled={(value ?? 0) >= max}
            onMouseDown={startPress(+step)}
            onTouchStart={startPress(+step)}
            onContextMenu={(e) => e.preventDefault()}
          >
            <span aria-hidden>+</span>
          </button>

          <span className="unit">小时</span>
          <input
            id="sessionDuration"
            type="number"
            min={min}
            max={max}
            step={step}
            value={value}
            onChange={(e) => setValue(e.target.value)}
            onBlur={(e) => setValue(e.target.value)}
            aria-label="单次上课时长（小时）"
            style={{ display: 'none' }}
          />
        </div>
      </div>

      <div className="times-list" role="list" ref={listRef}>
        {timeSlots.map((t, idx) => {
          const isSelected = selectedIndexSet.has(idx);
          return (
            <button
              key={`${t.h}-${t.m}-${idx}`}
              type="button"
              className={`time-slot ${isSelected ? 'selected' : ''}`}
              data-index={idx}
              data-time-slot={t.label}
              onClick={() => handleClickSlot(idx)}
              aria-pressed={isSelected}   // ? 合法（按钮/role=button 可用）
            >
              <span className="dot" aria-hidden />
              <span className="time-text">{t.label}</span>
            </button>
          );
        })}
      </div>
    </div>
  );
});


// 懒加载 dotlottie React 播放器

const DotLottiePlayer = lazy(async () => {                                     // 懒加载定义
  const mod = await import('@dotlottie/react-player');                         // 动态引入包
  const Cmp =
    // ① 常见：命名导出 Player
    mod?.Player
    // ② 有些版本：默认导出就是组件
    || mod?.default
    // ③ 少数版本：默认导出是对象，其中的 Player 才是组件
    || mod?.default?.Player
    // ④ 极少版本：导出名叫 DotLottiePlayer
    || mod?.DotLottiePlayer;

  if (!Cmp) {                                                                  // 若仍未命中
    // 给出更明确的提示，方便你 ctrl+点击 node_modules 查看 package.json 的 "exports"
    throw new Error('[dotlottie] no found（Tries Player/default/default.Player/DotLottiePlayer）');
  }
  return { default: Cmp };                                                     // 映射为 lazy 需要的 default
});

const STEPS = [
  {
    id: 'direction',
    label: '第 1 步',
    title: '明确你的学习方向',
    description:
      '在这一步，我们会帮助你快速对齐目标与期望，明确你需要学习的学科门类。',
  },  { id: 'details',
    label: '第 2 步',
    title: '补充课程细节',
    description:
      '告诉我们详细的课程类型，以及你期望达成的里程碑。',
  },
  {
    id: 'schedule',
    label: '第 3 步',
    title: '告知时区与可授课时间',
    description:
      'MentorX 会根据你的时区和可授课时间，为你匹配最适合的导师。',
  },
  {
    id: 'upload',
    label: '第 4 步',
    title: '很好！这是最后一步',
    description:
      '你可以预览在导师页面你的个人信息的呈现效果，并在下方上传你的课件。',
  },
];

const DIRECTION_OPTIONS = [
  { id: 'cs-foundation', label: '编程基础' },
  { id: 'algo', label: '数据结构与算法' },
  { id: 'ml', label: '机器学习' },
  { id: 'ai-large-model', label: 'AI 大模型' },
  { id: 'data-analysis', label: '数据分析' },
  { id: 'advanced-math', label: '高等数学' },
  { id: 'statistics', label: '概率与统计' },
  { id: 'physics', label: '物理学' },
  { id: 'life-science', label: '生命科学' },
  { id: 'chemistry', label: '化学' },
  { id: 'materials-science', label: '材料科学' },
  { id: 'software-engineering', label: '软件工程' },
  { id: 'cybersecurity', label: '网络安全' },
  { id: 'finance', label: '金融学' },
  { id: 'accounting', label: '会计学' },
  { id: 'economics', label: '经济学' },
  { id: 'marketing', label: '市场营销' },
  { id: 'operations', label: '运营管理' },
  { id: 'project-management', label: '项目管理' },
  { id: 'psychology', label: '心理学' },
  { id: 'design-creative', label: '设计 / 创意' },
  { id: 'linguistics', label: '语言学' },
  { id: 'communication-studies', label: '传播学' },
  { id: 'law', label: '法律' },
  { id: 'writing', label: '论文写作与润色' },
  { id: 'career-coaching', label: '求职辅导' },
  { id: 'others', label: '其它课程方向' },
];

// 方向图标映射
const DIRECTION_ICONS = {
  'cs-foundation': <FaCode />,
  'algo': <FaProjectDiagram />,
  'ml': <FaRobot />,
  'ai-large-model': <RiAiGenerate />,
  'data-analysis': <FaChartBar />,
  'advanced-math': <FaCalculator />,
  'statistics': <FaChartPie />,
  'physics': <FaAtom />,
  'life-science': <FaDna />,
  'chemistry': <FaFlask />,
  'materials-science': <FaCubes />,
  'software-engineering': <FaLaptopCode />,
  'cybersecurity': <FaShieldAlt />,
  'finance': <FaDollarSign />,
  'accounting': <FaCalculator />,
  'economics': <FaUniversity />,
  'marketing': <FaBullhorn />,
  'operations': <FaCogs />,
  'project-management': <FaTasks />,
  'psychology': <FaBrain />,
  'design-creative': <FaPalette />,
  'linguistics': <FaLanguage />,
  'communication-studies': <FaBroadcastTower />,
  'law': <FaBalanceScale />,
  'writing': <FaFileAlt />,
  'career-coaching': <FaUserTie />,
  'others': <FaEllipsisH />,
};
const COURSE_TYPE_OPTIONS = [
  { id: 'course-selection', label: '选课指导', icon: <FaLightbulb /> },
  { id: 'pre-study', label: '课前预习', icon: <FaCalendarAlt /> },
  { id: 'assignment-project', label: '作业项目', icon: <FaTasks /> },
  { id: 'final-review', label: '期末复习', icon: <FaClock /> },
  { id: 'in-class-support', label: '毕业论文', icon: <FaGraduationCap /> },
  { id: 'others', label: '其它类型', icon: <FaEllipsisH /> },
];


const TIMEZONE_NAME_OVERRIDES = {
  'Asia/Shanghai': '\u4e2d\u56fd\u6807\u51c6\u65f6\u95f4',
  'Asia/Tokyo': '\u65e5\u672c\u6807\u51c6\u65f6\u95f4',
  'Asia/Bangkok': '\u6cf0\u56fd\u65f6\u95f4',
  'Asia/Dubai': '\u6d77\u6e7e\u6807\u51c6\u65f6\u95f4',
  'Europe/London': '\u683c\u6797\u5c3c\u6c0f\u6807\u51c6\u65f6\u95f4',
  'Europe/Berlin': '\u4e2d\u6b27\u6807\u51c6\u65f6\u95f4',
  'Europe/Moscow': '\u83ab\u65af\u79d1\u65f6\u95f4',
  'America/Los_Angeles': '\u7f8e\u56fd\u592a\u5e73\u6d0b\u65f6\u95f4',
  'America/Denver': '\u7f8e\u56fd\u5c71\u5730\u65f6\u95f4',
  'America/Chicago': '\u7f8e\u56fd\u4e2d\u90e8\u65f6\u95f4',
  'America/New_York': '\u7f8e\u56fd\u4e1c\u90e8\u65f6\u95f4',
  'America/Sao_Paulo': '\u5df4\u897f\u5229\u4e9a\u65f6\u95f4',
  'Pacific/Auckland': '\u65b0\u897f\u5170\u6807\u51c6\u65f6\u95f4',
  'Australia/Brisbane': '\u6fb3\u5927\u5229\u4e9a\u4e1c\u90e8\u65f6\u95f4',
  'America/Halifax': '\u52a0\u62ff\u5927\u5927\u897f\u6d0b\u65f6\u95f4',
  'America/Anchorage': '\u7f8e\u56fd\u963f\u62c9\u65af\u52a0\u65f6\u95f4',
  'Pacific/Honolulu': '\u590f\u5a01\u5937\u65f6\u95f4',
  'Pacific/Pago_Pago': '\u8428\u6469\u4e9a\u65f6\u95f4',
  'Atlantic/Azores': '\u4e9a\u901f\u5c14\u7fa4\u5c9b\u65f6\u95f4',
  'Atlantic/South_Georgia': '\u5357\u4e54\u6cbb\u4e9a\u65f6\u95f4',
  'Africa/Johannesburg': '\u5357\u975e\u65f6\u95f4',
  'Asia/Karachi': '\u5df4\u57fa\u65af\u5766\u6807\u51c6\u65f6\u95f4',
  'Asia/Dhaka': '\u5b5f\u52a0\u62c9\u56fd\u6807\u51c6\u65f6\u95f4',
  'Pacific/Guadalcanal': '\u6240\u7f57\u95e8\u7fa4\u5c9b\u65f6\u95f4',
};

// 24 curated time zones: one representative per UTC hour offset (-11 to +12)
const FALLBACK_TIMEZONES = [
  'Pacific/Pago_Pago',       // UTC-11
  'Pacific/Honolulu',        // UTC-10
  'America/Anchorage',       // UTC-09
  'America/Los_Angeles',     // UTC-08
  'America/Denver',          // UTC-07
  'America/Chicago',         // UTC-06
  'America/New_York',        // UTC-05
  'America/Halifax',         // UTC-04
  'America/Sao_Paulo',       // UTC-03
  'Atlantic/South_Georgia',  // UTC-02
  'Atlantic/Azores',         // UTC-01
  'Europe/London',           // UTC±00
  'Europe/Berlin',           // UTC+01
  'Africa/Johannesburg',     // UTC+02 (no DST)
  'Europe/Moscow',           // UTC+03
  'Asia/Dubai',              // UTC+04
  'Asia/Karachi',            // UTC+05
  'Asia/Dhaka',              // UTC+06
  'Asia/Bangkok',            // UTC+07
  'Asia/Shanghai',           // UTC+08
  'Asia/Tokyo',              // UTC+09
  'Australia/Brisbane',      // UTC+10 (no DST)
  'Pacific/Guadalcanal',     // UTC+11
  'Pacific/Auckland',        // UTC+12
];

const extractCityName = (timeZone) => {
  if (!timeZone) {
    return '';
  }
  const segments = timeZone.split('/');
  if (segments.length <= 1) {
    return timeZone.replace(/_/g, ' ');
  }
  return segments.slice(1).join(' / ').replace(/_/g, ' ');
};

const getTimeZoneOffsetMinutes = (timeZone, referenceDate = new Date()) => {
  try {
    const formatter = new Intl.DateTimeFormat('en-US', {
      timeZone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false,
    });
    const parts = formatter.formatToParts(referenceDate).reduce((accumulator, part) => {
      if (part.type !== 'literal') {
        accumulator[part.type] = part.value;
      }
      return accumulator;
    }, {});
    const isoString = `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}:${parts.second}.000Z`;
    const tzAsUTC = new Date(isoString);
    const offsetMinutes = Math.round((tzAsUTC.getTime() - referenceDate.getTime()) / 60000);
    return offsetMinutes;
  } catch (error) {
    return 0;
  }
};

const formatTimeZoneOffset = (timeZone, referenceDate = new Date()) => {
  try {
    const offsetMinutes = getTimeZoneOffsetMinutes(timeZone, referenceDate);
    const sign = offsetMinutes >= 0 ? '+' : '-';
    const absMinutes = Math.abs(offsetMinutes);
    const hours = String(Math.floor(absMinutes / 60)).padStart(2, '0');
    const minutes = String(absMinutes % 60).padStart(2, '0');
    return `(UTC${sign}${hours}:${minutes})`;
  } catch (error) {
    return '(UTC+00:00)';
  }
};

const buildTimeZoneLabel = (timeZone, referenceDate) => {
  const offset = formatTimeZoneOffset(timeZone, referenceDate);
  const cityName = extractCityName(timeZone);
  const overrideName = TIMEZONE_NAME_OVERRIDES[timeZone];
  const baseName = overrideName || cityName || timeZone;
  // Append English city name when available to keep clarity
  const suffix = overrideName && cityName && overrideName !== cityName ? ` - ${cityName}` : '';
  return `${offset} ${baseName}${suffix}`;
};

const getDefaultTimeZone = () => {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone || 'Asia/Shanghai';
  } catch (error) {
    return 'Asia/Shanghai';
  }
};

const buildTimeZoneOptions = (referenceDate = new Date()) => {
  // Only show curated 24 time zones to keep the list clean and simple
  return FALLBACK_TIMEZONES.map((timeZone) => ({
    value: timeZone,
    label: buildTimeZoneLabel(timeZone, referenceDate),
  }));
};

// Order options so that:
// - time zones later than the selected are listed first (above),
// - selected time zone in the middle,
// - earlier time zones listed after (below).
const orderTimeZoneOptionsAroundSelected = (options, selectedValue, referenceDate = new Date()) => {
  if (!selectedValue) return options;
  const decorated = options.map((o) => ({
    ...o,
    _offset: getTimeZoneOffsetMinutes(o.value, referenceDate),
  }));
  const selectedOffset = getTimeZoneOffsetMinutes(selectedValue, referenceDate);

  const later = decorated.filter((o) => o._offset > selectedOffset).sort((a, b) => b._offset - a._offset);
  const earlier = decorated.filter((o) => o._offset < selectedOffset).sort((a, b) => b._offset - a._offset);

  const selectedInList = decorated.find((o) => o.value === selectedValue);
  const selectedOption =
    selectedInList || {
      value: selectedValue,
      label: buildTimeZoneLabel(selectedValue, referenceDate),
      _offset: selectedOffset,
    };

  const result = [...later, selectedOption, ...earlier].map(({ _offset, ...rest }) => rest);
  // Deduplicate by value in case selected already existed
  const seen = new Set();
  return result.filter((o) => {
    if (seen.has(o.value)) return false;
    seen.add(o.value);
    return true;
  });
};

const DEFAULT_TIME_ZONE = getDefaultTimeZone();


const INITIAL_FORM_STATE = {
  learningGoal: '国际课程 / 升学',
  courseDirection: '',
  courseType: '',
  courseTypes: [],
  courseFocus: '',
  format: '线上授课',
  milestone: '',
  // 预计课程总时长（小时）
  totalCourseHours: '',
  availability: DEFAULT_TIME_ZONE,
  sessionDurationHours: 2,
  contactName: '',
  contactMethod: '微信',
  contactValue: '',
  attachments: [],
};

const PAGE_TRANSITION_DURATION = 400;

// ---- Preview helpers (mock profile + formatting) ----
const pickOne = (arr) => arr[Math.floor(Math.random() * arr.length)] || '';
const MOCK_SCHOOLS = ['斯坦福大学', '清华大学', '麻省理工学院', '北京大学', '多伦多大学', '新加坡国立大学'];
const MOCK_LEVELS = ['本科', '硕士', '博士'];

const buildShortUTC = (timeZone) => {
  if (!timeZone) return 'UTC±0';
  try {
    const offMin = getTimeZoneOffsetMinutes(timeZone, new Date());
    const sign = offMin >= 0 ? '+' : '-';
    const hours = Math.floor(Math.abs(offMin) / 60);
    const mins = Math.abs(offMin) % 60;
    const minsPart = mins ? `:${String(mins).padStart(2, '0')}` : '';
    return `UTC${sign}${hours}${minsPart}`;
  } catch (e) {
    return 'UTC±0';
  }
};

const generateMockStudentProfile = () => {
  const id = Math.floor(10 + Math.random() * 90);
  return {
    name: `Student${id}`,
    level: pickOne(MOCK_LEVELS),
    school: pickOne(MOCK_SCHOOLS),
  };
};

function StudentCourseRequestPage() {
  const navigate = useNavigate();
  const [currentStepIndex, setCurrentStepIndex] = useState(0);
  const [formData, setFormData] = useState(INITIAL_FORM_STATE);
  const [isCompleted, setIsCompleted] = useState(false);
  const [isDirectionSelection, setIsDirectionSelection] = useState(false);
  const [isCourseTypeSelection, setIsCourseTypeSelection] = useState(false);
  const [transitionStage, setTransitionStage] = useState('idle');
  const pendingActionRef = useRef(null);
  const isMountedRef = useRef(true);

  // Stable mock profile for preview (when student info is missing)
  const mockStudent = useMemo(() => generateMockStudentProfile(), []);

  // ----- Schedule step local states -----
  const [selectedDate, setSelectedDate] = useState(() => new Date());
  const [viewMonth, setViewMonth] = useState(() => new Date(new Date().getFullYear(), new Date().getMonth(), 1));
  const timesListRef = useRef(null);
  const defaultTimesScrollDoneRef = useRef(false);
  // 每天对应的已选时间段集合（按索引区间存储）
  const [daySelections, setDaySelections] = useState({}); // key: 'YYYY-MM-DD' -> [{start,end}]
  const getBlocksForDay = useCallback((key) => daySelections[key] || [], [daySelections]);
  const setBlocksForDay = useCallback((key, next) => {
    setDaySelections((prev) => ({ ...prev, [key]: next }));
  }, []);

  // Drag-to-select range across dates
  const [selectedRangeKeys, setSelectedRangeKeys] = useState([]);
  const [dragStartKey, setDragStartKey] = useState(null);
  const [dragEndKey, setDragEndKey] = useState(null);
  const [isDraggingRange, setIsDraggingRange] = useState(false);
  const [dragPreviewKeys, setDragPreviewKeys] = useState(new Set());
  const didDragRef = useRef(false);

  // Upload step states
  const fileInputRef = useRef(null);
  const [isDraggingFiles, setIsDraggingFiles] = useState(false);

  const buildKey = useCallback((d) => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`,[/*no deps*/]);
  const keyToDateStrict = useCallback((key) => {
    if (!key) return null;
    const [y,m,d] = key.split('-').map((s)=>parseInt(s,10));
    if (!y||!m||!d) return null;
    return new Date(y, m-1, d);
  }, []);



  // Start-of-today reference for past/future checks
  const todayStart = useMemo(() => {
    const t = new Date();
    t.setHours(0, 0, 0, 0);
    return t;
  }, []);


  
  const enumerateKeysInclusive = useCallback((aKey, bKey) => {
    const a = keyToDateStrict(aKey);
    const b = keyToDateStrict(bKey);
    if (!a || !b) return [];
    const start = a.getTime() <= b.getTime() ? a : b;
    const end = a.getTime() <= b.getTime() ? b : a;
    const res = [];
    const cur = new Date(start);
    cur.setHours(0,0,0,0);
    const endTs = new Date(end.getFullYear(), end.getMonth(), end.getDate()).getTime();
    while (cur.getTime() <= endTs) {
      const t = new Date(cur);
      const isPast = (() => { const dd = new Date(t); dd.setHours(0,0,0,0); return dd.getTime() < todayStart.getTime(); })();
      if (!isPast) res.push(buildKey(t));
      cur.setDate(cur.getDate()+1);
    }
    return res;
  }, [buildKey, keyToDateStrict, todayStart]);

  const endDragSelection = useCallback(() => {
    if (!isDraggingRange || !dragStartKey || !dragEndKey) {
      setIsDraggingRange(false);
      setDragPreviewKeys(new Set());
      return;
    }
    const keys = enumerateKeysInclusive(dragStartKey, dragEndKey);
    setSelectedRangeKeys(keys);
    const endDate = keyToDateStrict(dragEndKey);
    if (endDate) setSelectedDate(endDate);
    setIsDraggingRange(false);
    setDragPreviewKeys(new Set());
  }, [dragEndKey, dragStartKey, enumerateKeysInclusive, isDraggingRange, keyToDateStrict]);

  useEffect(() => {
    const onUp = () => {
      if (isDraggingRange) {
        endDragSelection();
        didDragRef.current = true;
      }
    };
    window.addEventListener('mouseup', onUp);
    return () => window.removeEventListener('mouseup', onUp);
  }, [endDragSelection, isDraggingRange]);

  // 月份滑动方向：'left' 表示点“下一月”，新网格从右往中滑入；'right' 表示点“上一月”
  const [monthSlideDir, setMonthSlideDir] = useState(null); // 初始为 null，表示无动画方向

  // 每次切月自增 key，强制重挂载 calendar-grid 以触发入场动画
  const [monthSlideKey, setMonthSlideKey] = useState(0);    // 初始为 0
  
  useEffect(() => () => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;   // 卸载时再关掉
    };
  }, []);

  useEffect(() => {
    // 首次进入页面时走一次进入动画
    setTransitionStage('entering');
  }, []);
  
  useEffect(() => {
    if (transitionStage === 'exiting') {
      const timeout = setTimeout(() => {
        const action = pendingActionRef.current;
        if (action) {
          action();
        }
        pendingActionRef.current = null;
        if (!isMountedRef.current) {
          return;
        }
        setTransitionStage('entering');
      }, PAGE_TRANSITION_DURATION);
      return () => clearTimeout(timeout);
    }

    if (transitionStage === 'entering') {
      const timeout = setTimeout(() => {
        if (!isMountedRef.current) {
          return;
        }
        setTransitionStage('idle');
      }, PAGE_TRANSITION_DURATION);
      return () => clearTimeout(timeout);
    }

    return undefined;
  }, [transitionStage]);

  const currentStep = useMemo(() => STEPS[currentStepIndex], [currentStepIndex]);
  // Ordered options based on current selection
  const orderedTimeZoneOptions = useMemo(() => {
    const referenceDate = new Date();
    // Build fresh labels for consistency with any future date logic
    const base = buildTimeZoneOptions(referenceDate);
    return orderTimeZoneOptionsAroundSelected(base, formData.availability, referenceDate);
  }, [formData.availability]);

  // Custom Select: Time zone dropdown that centers current option
  const TimeZoneSelect = ({ id, value, onChange, options }) => {
    const [open, setOpen] = useState(false);
    const buttonRef = useRef(null);
    const listRef = useRef(null);

    useEffect(() => {
      if (!open) return;
      const listEl = listRef.current;
      if (!listEl) return;
      const idx = options.findIndex((o) => o.value === value);
      if (idx === -1) return;
      const itemEl = listEl.querySelector(`[data-index="${idx}"]`);
      if (!itemEl) return;
      // Scroll so that selected item is approximately centered
      const listHeight = listEl.clientHeight;
      const itemTop = itemEl.offsetTop;
      const itemHeight = itemEl.offsetHeight;
      const targetScroll = itemTop - Math.max(0, (listHeight - itemHeight) / 2);
      try {
        listEl.scrollTo({ top: targetScroll, behavior: 'auto' });
      } catch (_) {
        listEl.scrollTop = targetScroll;
      }
    }, [open, options, value]);

    useEffect(() => {
      const onDocClick = (e) => {
        if (!open) return;
        const btn = buttonRef.current;
        const list = listRef.current;
        if (btn && btn.contains(e.target)) return;
        if (list && list.contains(e.target)) return;
        setOpen(false);
      };
      document.addEventListener('mousedown', onDocClick);
      return () => document.removeEventListener('mousedown', onDocClick);
    }, [open]);

    const selectedLabel = useMemo(() => {
      const found = options.find((o) => o.value === value);
      return found ? found.label : '';
    }, [options, value]);

    const handleKeyDown = (e) => {
      if (e.key === 'Escape') {
        setOpen(false);
        return;
      }
      if (!open && (e.key === 'Enter' || e.key === ' ')) {
        e.preventDefault();
        setOpen(true);
        return;
      }
      if (!open) return;
      const currentIndex = Math.max(0, options.findIndex((o) => o.value === value));
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        const next = Math.min(options.length - 1, currentIndex + 1);
        onChange({ target: { value: options[next].value } });
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        const prev = Math.max(0, currentIndex - 1);
        onChange({ target: { value: options[prev].value } });
      } else if (e.key === 'Enter') {
        e.preventDefault();
        setOpen(false);
      }
    };

    return (
      <div className="mx-select" data-open={open ? 'true' : 'false'}>
        <button
          id={id}
          ref={buttonRef}
          type="button"
          className="mx-select__button"
          aria-haspopup="listbox"
          aria-expanded={open}
          onClick={() => setOpen((v) => !v)}
          onKeyDown={handleKeyDown}
        >
          <span className="mx-select__label">{selectedLabel || '请选择'}</span>
          <span className="mx-select__caret" aria-hidden>
            ?
          </span>
        </button>
        {open && (
          <div className="mx-select__popover">
            <ul
              ref={listRef}
              role="listbox"
              aria-labelledby={id}
              className="mx-select__list"
            >
              {options.map((opt, index) => {
                const selected = opt.value === value;
                return (
                  <li
                    key={opt.value}
                    role="option"
                    aria-selected={selected}
                    data-index={index}
                    className={`mx-select__option ${selected ? 'selected' : ''}`}
                    onClick={() => {
                      onChange({ target: { value: opt.value } });
                      setOpen(false);
                    }}
                  >
                    {opt.label}
                  </li>
                );
              })}
            </ul>
          </div>
        )}
      </div>
    );
  };
  
  const isDirectionStep = currentStep.id === 'direction';  const isDetailsStep = currentStep.id === 'details';
  const isScheduleStep = currentStep.id === 'schedule';
  const isUploadStep = currentStep.id === 'upload';
  
  const isDirectionSelectionStage = isDirectionStep && isDirectionSelection;
  
  const startPageTransition = (action) => {
    if (typeof action !== 'function') {
      return;
    }
    if (transitionStage !== 'idle') {
      return;
    }
    pendingActionRef.current = action;
    setTransitionStage('exiting');
  };

  const handleChange = (field) => (event) => {
    setFormData((previous) => ({
      ...previous,
      [field]: event.target.value,
    }));
  };

  // ----- Upload handlers -----
  const handleAddFiles = (filesLike) => {
    const list = Array.from(filesLike || []);
    if (!list.length) return;
    setFormData((prev) => ({
      ...prev,
      attachments: [...(prev.attachments || []), ...list],
    }));
  };

  const handleFileInputChange = (e) => {
    handleAddFiles(e.target.files);
    // reset input so selecting the same file again still triggers change
    if (e.target) e.target.value = '';
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  const handleDragEnter = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDraggingFiles(true);
  };
  const handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDraggingFiles(false);
  };
  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDraggingFiles(false);
    if (e.dataTransfer && e.dataTransfer.files) {
      handleAddFiles(e.dataTransfer.files);
    }
  };

  const handleRemoveAttachment = (index) => {
    setFormData((prev) => ({
      ...prev,
      attachments: (prev.attachments || []).filter((_, i) => i !== index),
    }));
  };
  const handleClearAttachments = () => {
    setFormData((prev) => ({ ...prev, attachments: [] }));
  };

  const handleNext = () => {
    startPageTransition(() => {
      if (currentStep.id === 'direction') {
        // 进入方向选择阶段时，默认选中第一个选项
        if (!isDirectionSelection) {
          setIsDirectionSelection(true);
          if (!formData.courseDirection && DIRECTION_OPTIONS.length > 0) {
            const first = DIRECTION_OPTIONS[0];
            setFormData((previous) => ({
              ...previous,
              courseDirection: first.id,
              learningGoal: first.label,
            }));
          }
          return;
        }
        // 已在选择界面则直接继续
        // 第二次：进入“课程类型”选择界面
        if (!isCourseTypeSelection) {
          setIsCourseTypeSelection(true);
          // 多选模式：不再默认选中任意类型
          return; // 仍停留在 direction 步骤
        }
      // 两个子阶段都完成后才进入下一个大步骤
      }

      if (currentStepIndex === STEPS.length - 1) {
        setIsCompleted(true);
        return;
      }
      setCurrentStepIndex((index) => Math.min(index + 1, STEPS.length - 1));
    });
  };

  const handleBack = () => {
    startPageTransition(() => {
      if (currentStep.id === 'direction' && isDirectionSelection && isCourseTypeSelection) {
        setIsCourseTypeSelection(false);
        return;
      }
      if (currentStep.id === 'direction' && isDirectionSelection) {
        setIsDirectionSelection(false);
        return;
      }

      if (currentStepIndex === 0) {
        navigate('/student');
        return;
      }

      if (currentStep.id === 'details' ) {
        setIsDirectionSelection(true);
        setIsCourseTypeSelection(true);
      }
      setCurrentStepIndex((index) => Math.max(index - 1, 0));
    });
  };

  const transitionClassName =
    transitionStage === 'exiting'
      ? 'page-transition-exit'
      : transitionStage === 'entering'
        ? 'page-transition-enter'
        : '';

  const stepLayoutClassName = [
    'step-layout',
    isDirectionSelectionStage ? 'direction-selection-layout' : '',
    isUploadStep ? 'contact-preview-layout' : '',
    transitionClassName,
  ]
    .filter(Boolean)
    .join(' ');

  const stepContentClassName = [
    'step-content',
    (isDirectionStep || isDetailsStep) ? 'direction-layout' : '',
    isDirectionSelectionStage ? 'direction-selection' : '',
    isScheduleStep ? 'schedule-content' : '',
  ]
    .filter(Boolean)
    .join(' ');

  const stepFooterClassName = ['step-footer', transitionClassName].filter(Boolean).join(' ');

  const units = currentStepIndex === 0 ? (isDirectionSelection ? (isCourseTypeSelection ? 1 : 0.5) : 0) : currentStepIndex + 1;
  const progress = (units / STEPS.length) * 100;
  //const progress = ((currentStepIndex + 1) / STEPS.length) * 100;

  // ---- Data for contact-step preview card ----
  const previewName = formData.contactName?.trim() || mockStudent.name;
  const previewLevel = mockStudent.level;
  const previewSchool = mockStudent.school;
  const previewDirectionLabel = useMemo(() => {
    const found = DIRECTION_OPTIONS.find((o) => o.id === formData.courseDirection);
    return found?.label || formData.learningGoal || '未选择方向';
  }, [formData.courseDirection, formData.learningGoal]);
  // Selected course type(s) label for preview
  const previewCourseTypeLabel = useMemo(() => {
    const ids = Array.isArray(formData.courseTypes)
      ? formData.courseTypes
      : (formData.courseType ? [formData.courseType] : []);
    const labels = ids
      .map((id) => COURSE_TYPE_OPTIONS.find((o) => o.id === id)?.label)
      .filter(Boolean);
    return labels.join('、');
  }, [formData.courseTypes, formData.courseType]);
  const earliestSelectedDay = useMemo(() => {
    const keys = Object.keys(daySelections || {}).filter((k) => (daySelections[k] || []).length > 0);
    if (!keys.length) return null;
    return keys.sort()[0];
  }, [daySelections]);
  const tzCity = useMemo(() => extractCityName(formData.availability), [formData.availability]);
  const tzShort = useMemo(() => buildShortUTC(formData.availability), [formData.availability]);
  // 仅当“预计课程总时长”有填时才在预览卡展示
  const hasTotalCourseHours = (formData.totalCourseHours !== '' && formData.totalCourseHours != null);
  const previewTotalCourseHours = hasTotalCourseHours ? Number(formData.totalCourseHours) : null;

  // ----- Schedule helpers -----
  const zhDays = ['日', '一', '二', '三', '四', '五', '六'];

  const monthLabel = useMemo(() => {
    const fmt = new Intl.DateTimeFormat('zh-CN', { year: 'numeric', month: 'long' });
    return fmt.format(viewMonth);
  }, [viewMonth]);

  const buildCalendarGrid = useMemo(() => {
    const first = new Date(viewMonth.getFullYear(), viewMonth.getMonth(), 1);
    const startIdx = first.getDay(); // 0=Sun
    const daysInMonth = new Date(viewMonth.getFullYear(), viewMonth.getMonth() + 1, 0).getDate();
    const prevMonthDays = new Date(viewMonth.getFullYear(), viewMonth.getMonth(), 0).getDate();

    const cells = [];
    for (let i = startIdx - 1; i >= 0; i--) {
      const dayNum = prevMonthDays - i;
      const date = new Date(viewMonth.getFullYear(), viewMonth.getMonth() - 1, dayNum);
      cells.push({ date, outside: true });
    }
    for (let d = 1; d <= daysInMonth; d++) {
      cells.push({ date: new Date(viewMonth.getFullYear(), viewMonth.getMonth(), d), outside: false });
    }
    while (cells.length % 7 !== 0) {
      const last = cells[cells.length - 1].date;
      const next = new Date(last);
      next.setDate(last.getDate() + 1);
      cells.push({ date: next, outside: true });
    }
    while (cells.length < 42) {
      const last = cells[cells.length - 1].date;
      const next = new Date(last);
      next.setDate(last.getDate() + 1);
      cells.push({ date: next, outside: next.getMonth() !== viewMonth.getMonth() });
    }
    return cells;
  }, [viewMonth]);

  const isSameDay = (a, b) => (
    a.getFullYear() === b.getFullYear() &&
    a.getMonth() === b.getMonth() &&
    a.getDate() === b.getDate()
  );

  // 规范化日期 key（不含时区偏移影响）
  const ymdKey = (d) => `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;



  // 点“上一月”按钮时触发
  const handlePrevMonth = () => {                                        // 定义上一月处理函数
    setMonthSlideDir('right');                                            // 设置动画方向为从左滑入（上一月）
    setMonthSlideKey((k) => k + 1);                                       // 自增 key 触发动画
    setViewMonth((m) => new Date(m.getFullYear(), m.getMonth() - 1, 1));  // 视图月份减一
  };
  // 点“下一月”按钮时触发
  const handleNextMonth = () => {                                        // 定义下一月处理函数
    setMonthSlideDir('left');                                            // 设置动画方向为从右滑入（下一月）
    setMonthSlideKey((k) => k + 1);                                      // 自增 key 触发动画
    setViewMonth((m) => new Date(m.getFullYear(), m.getMonth() + 1, 1)); // 视图月份加一
  };

  

  // ? 用这个替换你现在的“默认滚动到 09:00”的 useEffect
  useEffect(() => {
    // 只在日程页 & 过场动画结束(transitionStage === 'idle')时执行一次
    if (currentStep.id !== 'schedule' || transitionStage !== 'idle') return;
    if (defaultTimesScrollDoneRef.current) return;
  
    const listEl = timesListRef.current;
    if (!listEl) return;
  
    const targetEl = listEl.querySelector('[data-time-slot="09:00"]');
    if (!targetEl) return;
  
    const apply = () => {
      try {
        // 不要用 smooth，这里要“硬定位”
        listEl.scrollTop = targetEl.offsetTop;
      } catch {}
    };
  
    // 等一帧 -> 设一次 -> 再等一帧 -> 再设一次 -> 再兜底一次
    requestAnimationFrame(() => {
      apply();
      requestAnimationFrame(() => {
        apply();
        setTimeout(apply, 0);
      });
    });
  
    defaultTimesScrollDoneRef.current = true;
  }, [currentStep.id, transitionStage]);





  const renderStepContent = () => {
    switch (currentStep.id) {
      case 'direction':
        if (!isDirectionSelection) {
          return null;
        }
        if (isCourseTypeSelection) {
          return (
            <div className="direction-select">
              <div className="direction-grid two-col-grid" role="list">
                {COURSE_TYPE_OPTIONS.map((option, index) => {
                  const selectedList = Array.isArray(formData.courseTypes) ? formData.courseTypes : [];
                  const isActive = selectedList.includes(option.id);
                  return (
                    <button
                      key={option.id}
                      type="button"
                      role="listitem"
                      className={`direction-card ${isActive ? 'active' : ''}`}
                      style={{ '--card-index': index }}
                      onClick={() => {
                        setFormData((previous) => {
                          const list = Array.isArray(previous.courseTypes) ? previous.courseTypes : [];
                          const exists = list.includes(option.id);
                          const nextList = exists ? list.filter(id => id !== option.id) : [...list, option.id];
                          return {
                            ...previous,
                            courseTypes: nextList,
                            // 同步一个代表值以便兼容旧字段
                            courseType: nextList[0] || '',
                          };
                        });
                      }}
                    >
                      <span className="direction-card__icon" aria-hidden="true">
                        {option.icon}
                      </span>
                      <span className="direction-card__title">{option.label}</span>
                    </button>
                  );
                })}
              </div>
            </div>
          );
        }
        return (
          <div className="direction-select">
            <div className="direction-grid" role="list">
              {DIRECTION_OPTIONS.map((option, index) => {
                const isActive = formData.courseDirection === option.id;
                return (
                  <button
                    key={option.id}
                    type="button"
                    role="listitem"
                    className={`direction-card ${isActive ? 'active' : ''}`}
                    style={{ '--card-index': index }}
                    onClick={() => {
                      setFormData((previous) => ({
                        ...previous,
                        courseDirection: option.id,
                        learningGoal: option.label,
                      }));
                    }}
                  >
                    <span className="direction-card__icon" aria-hidden="true">
                      {DIRECTION_ICONS[option.id] || <FaEllipsisH />}
                    </span>
                    <span className="direction-card__title">{option.label}</span>
                  </button>
                );
              })}
            </div>
          </div>
        );
      case 'details':
        return (
          <div className="step-field-stack">
            <div className="step-field-group">
              <label className="field-label" htmlFor="totalCourseHours">预计课程总时长</label>
              <div className="hours-input">
                <input
                  id="totalCourseHours"
                  type="number"
                  min={1}
                  step={1}
                  inputMode="numeric"
                  placeholder="例如：10"
                  value={formData.totalCourseHours}
                  onChange={handleChange('totalCourseHours')}
                />
                <span className="unit">小时</span>
              </div>
            </div>

            <div className="step-field-group">
              <label className="field-label" htmlFor="courseFocus">想重点提升的内容</label>
              <textarea
                id="courseFocus"
                placeholder={'例如： Biomedical Engineering这门课的Quiz1和Quiz2需要讲解。\n\n也可以在这里添加你的其它个人需求,例如：希望老师对着PPT讲的细致一些'}
                value={formData.courseFocus}
                onChange={handleChange('courseFocus')}
                rows={5}
              />
            </div>

            <div className="step-field-group">
              <label className="field-label" htmlFor="milestone">希望达成的目标或里程碑</label>
              <textarea
                id="milestone"
                type="text"
                placeholder="例如：6周后期末考试稳分达到A"
                value={formData.milestone}
                onChange={handleChange('milestone')}
              />
            </div>
          </div>
        );
      case 'schedule': {
        return (
          <div className="step-field-stack">
            <label className="field-label" htmlFor="availability">选择首课时区</label>
            <TimeZoneSelect
              id="availability"
              value={formData.availability}
              onChange={handleChange('availability')}
              options={orderedTimeZoneOptions}
            />
            <div className="calendar-card" aria-label="可授课时间日历">
              <div className="calendar-header">
                <div className="month-label">{monthLabel}</div>
                <div className="calendar-nav">
                  <button                                           // 上一月按钮
                    type="button"                                   // 按钮类型
                    className="nav-btn"                             // 样式类
                    aria-label="Prev month"                         // 无障碍说明
                    disabled={viewMonth.getFullYear() === todayStart.getFullYear() && viewMonth.getMonth() === todayStart.getMonth()} // 禁用到本月前
                    onClick={handlePrevMonth}                       // 使用封装好的上一月函数
                  >&lsaquo;</button>

                  <button                                           // 下一月按钮
                    type="button"                                   // 按钮类型
                    className="nav-btn"                             // 样式类
                    aria-label="Next month"                         // 无障碍说明
                    onClick={handleNextMonth}                       // 使用封装好的下一月函数
                  >&rsaquo;</button>

                </div>
              </div>
              <div className="calendar-grid">
                {zhDays.map((d) => (
                  <div key={d} className="day-name">{d}</div>
                ))}
                {buildCalendarGrid.map(({ date, outside }) => {
                  if (outside) {
                    return <div key={date.toISOString()} className="date-cell outside" aria-hidden />;
                  }
                  const isToday = isSameDay(date, new Date());
                  const selected = isSameDay(date, selectedDate);
                  const isPast = (() => {
                    const d = new Date(date);
                    d.setHours(0, 0, 0, 0);
                    return d.getTime() < todayStart.getTime();
                  })();
                  const cls = [
                    'date-cell',
                    isToday ? 'today' : '',
                    selected ? 'selected' : '',
                    isPast ? 'past' : '',
                  ].filter(Boolean).join(' ');
                  return (
                    <button
                      key={date.toISOString()}
                      type="button"
                      className={cls}
                      onClick={() => {
                        setSelectedDate(date);
                        if (date.getMonth() !== viewMonth.getMonth() || date.getFullYear() !== viewMonth.getFullYear()) {
                          setViewMonth(new Date(date.getFullYear(), date.getMonth(), 1));
                        }
                      }}
                    >
                      <span className="date-number">{date.getDate()}</span>
                    </button>
                  );
                })}
              </div>
            </div>
          </div>
        );
      }
      case 'upload':
        return (
          <div className="step-field-stack">
            
            <div
              className={`upload-area ${isDraggingFiles ? 'dragover' : ''}`}
              onDragOver={handleDragOver}
              onDragEnter={handleDragEnter}
              onDragLeave={handleDragLeave}
              onDrop={handleDrop}
              role="button"
              tabIndex={0}
            >
              <div className="upload-icon" aria-hidden="true"><FaImages /></div>
              <div className="upload-title">拖放</div>
              <div className="upload-subtext">或上传课件</div>
              <button type="button" className="primary-button upload-btn" onClick={() => fileInputRef.current && fileInputRef.current.click()}>
                上传
              </button>
              <input
                ref={fileInputRef}
                type="file"
                multiple
                accept=".pdf,.ppt,.pptx,.doc,.docx,.png,.jpg,.jpeg,.zip"
                style={{ display: 'none' }}
                onChange={handleFileInputChange}
              />
            </div>

            {(formData.attachments && formData.attachments.length > 0) && (
              <div className="file-list">
                {formData.attachments.map((f, idx) => (
                  <div key={idx} className="file-item">
                    <div className="meta">
                      <span className="name">{f.name}</span>
                      <span className="size">{(f.size / 1024 / 1024).toFixed(2)} MB</span>
                    </div>
                    <button
                      type="button"
                      className="icon-button remove"
                      aria-label="移除文件"
                      title="移除文件"
                      onClick={() => handleRemoveAttachment(idx)}
                    >
                      <RiDeleteBin6Line />
                    </button>
                  </div>
                ))}
                <div className="file-actions">
                  <button type="button" className="ghost-button" onClick={handleClearAttachments}>清空所有</button>
                </div>
              </div>
            )}
          </div>
        );
      default:
        return null;
    }
  };

  if (isCompleted) {
    const completionClassName = ['completion-content', transitionClassName].filter(Boolean).join(' ');
    return (
      <div className="course-request-page">        <main className={completionClassName}>
          <div className="completion-card">
            <h2>提交成功！</h2>
            <p>我们已经收到你的课程需求，学习顾问会在 24 小时内与你取得联系。</p>
            <div className="completion-actions">
              <button type="button" onClick={() => navigate('/student')}>
                返回学生首页
              </button>
              <button
                type="button"
                onClick={() => {
                  startPageTransition(() => {
                    setIsCompleted(false);
                    setCurrentStepIndex(0);
                    setIsDirectionSelection(false);
                  });
                }}
                disabled={transitionStage !== 'idle'}
              >
                重新填写
              </button>
            </div>
          </div>
        </main>
      </div>
    );
  }

  //const isDirectionStep = currentStep.id === 'direction';
  //  //const isDirectionSelectionStage = isDirectionStep && isDirectionSelection;

  return (
    <div className="course-request-page">
      <main className="request-flow">
        <div className="request-shell">
          <header className="step-header">
            <BrandMark to="/student" />
            <div className="step-header-actions">
              <button type="button" className="ghost-button">保存并退出</button>
            </div>
          </header>

          <section className={stepLayoutClassName}>
            {isUploadStep && !isDirectionSelectionStage && (
              <div className="contact-preview-floating" aria-label="导师页卡片预览">
                <div className="student-preview-card">
                  <div className="card-fav"><FaHeart /></div>
                  <div className="card-header">
                    <div className="avatar" aria-hidden="true">{previewName.slice(0,1).toUpperCase()}</div>
                    <div className="header-texts">
                      <div className="name">{previewName}</div>
                      <div className="chips">
                        <span className="chip green">{previewLevel}</span>
                        <span className="chip gray">{previewSchool}</span>
                      </div>
                    </div>
                  </div>
                  <div className="card-list" role="list">
                    <div className="item" role="listitem"><span className="icon"><FaGlobe /></span><span>{tzShort}                  （{tzCity || '时区'}）</span></div>
                    <div className="item" role="listitem"><span className="icon">{DIRECTION_ICONS[formData.courseDirection] || <FaFileAlt />}</span><span>{previewDirectionLabel}</span></div>
                    {!!previewCourseTypeLabel && (
                      <div className="item" role="listitem"><span className="icon"><FaGraduationCap /></span><span>课程类型：{previewCourseTypeLabel}</span></div>
                    )}
                    {hasTotalCourseHours && (
                      <div className="item" role="listitem"><span className="icon"><FaClock /></span><span>预计时长：{previewTotalCourseHours}小时</span></div>
                    )}
                    {!!(formData.courseFocus && formData.courseFocus.trim()) && (
                      <div className="item" role="listitem"><span className="icon"><FaLightbulb /></span><span>具体内容：{formData.courseFocus.trim()}</span></div>
                    )}
                    {!!(formData.milestone && formData.milestone.trim()) && (
                      <div className="item" role="listitem"><span className="icon"><FaTasks /></span><span>学习目标：{formData.milestone.trim()}</span></div>
                    )}
                    {earliestSelectedDay && (
                      <div className="item" role="listitem"><span className="icon"><FaCalendarAlt /></span><span>期望首课：{earliestSelectedDay}</span></div>
                    )}
                  </div>
                </div>
              </div>
            )}
            <div className={stepContentClassName}>
              <div className="step-intro">
                {!isDirectionSelectionStage && (
                  <React.Fragment>
                    <span className="step-label">{currentStep.label}</span>
                    <h1>{currentStep.title}</h1>
                  </React.Fragment>
                )}
                <p className={`step-description ${isDirectionSelectionStage ? 'direction-question' : ''}`}>
                  {isDirectionSelectionStage
                    ? (isCourseTypeSelection ? '请选择你的课程类型' : '以下哪一项最准确描述了你希望提升的课程？')
                    : currentStep.description}
                </p>
              </div>

              {isDirectionStep ? (
                isDirectionSelectionStage ? renderStepContent() : null
              ) : (
                isDetailsStep ? null : <div className="step-fields">{renderStepContent()}</div>
              )}
            </div>

            {!isDirectionSelectionStage && (
              isDetailsStep ? (
                <div className="details-right-panel">
                  {renderStepContent()}
                </div>
              ) : isScheduleStep ? (
                <div className="schedule-right-panel">
                  <div className="schedule-sidebar">
                    <div className="calendar-card slim" aria-label="可授课时间日历">
                      <div className="calendar-header">
                        <div className="month-label">{monthLabel}</div>
                        <div className="calendar-nav">
                          <button type="button" className="nav-btn" aria-label="Prev month" disabled={viewMonth.getFullYear() === todayStart.getFullYear() && viewMonth.getMonth() === todayStart.getMonth()} onClick={handlePrevMonth}>&lsaquo;</button>
                          <button type="button" className="nav-btn" aria-label="Next month" onClick={handleNextMonth}>&rsaquo;</button>
                        </div>
                      </div>
                      <div key={monthSlideKey}                           // 每次切月都改变 key，强制重挂载以触发动画
                        className={`calendar-grid ${                  // 绑定基础类与方向动画类
                          monthSlideDir === 'left'                    // 如果方向是 'left'（点“下一月”）
                            ? 'slide-in-left'                         // 新月份从右向中滑入
                            : monthSlideDir === 'right'               // 如果方向是 'right'（点“上一月”）
                            ? 'slide-in-right'                        // 新月份从左向中滑入
                            : ''                                      // 没有方向时，不加动画类
                        }`}
                      >
                        {zhDays.map((d) => (
                          <div key={d} className="day-name">{d}</div>
                        ))}
                        {buildCalendarGrid.map(({ date, outside }) => {
                          if (outside) {
                            return <div key={date.toISOString()} className="date-cell outside" aria-hidden />;
                          }
                          const isToday = isSameDay(date, new Date());
                          const key = ymdKey(date);
                          const selected = isSameDay(date, selectedDate);
                          const hasSelection = !!(daySelections[ymdKey(date)] && daySelections[ymdKey(date)].length);
                          const isPast = (() => {
                            const d = new Date(date);
                            d.setHours(0, 0, 0, 0);
                            return d.getTime() < todayStart.getTime();
                          })();
                          const inMultiSelected = (selectedRangeKeys || []).includes(key);
                          // Avoid preview style overriding selected/multi-selected cells
                          const inPreview = (dragPreviewKeys && dragPreviewKeys.size)
                            ? (dragPreviewKeys.has(key) && !selected && !inMultiSelected)
                            : false;
                          const cls = [
                            'date-cell',
                            isToday ? 'today' : '',
                            selected ? 'selected' : '',
                            isPast ? 'past' : '',
                            inMultiSelected ? 'multi-selected' : '',
                            inPreview ? 'range-preview' : '',
                          ].filter(Boolean).join(' ');
                          return (
                            <button
                              key={date.toISOString()}
                              type="button"
                              className={cls}
                              onMouseDown={() => {
                                if (isPast) return;
                                const k = ymdKey(date);
                                setIsDraggingRange(true);
                                setDragStartKey(k);
                                setDragEndKey(k);
                                setDragPreviewKeys(new Set([k]));
                                didDragRef.current = false;
                              }}
                              onMouseEnter={() => {
                                if (!isDraggingRange) return;
                                if (isPast) return;
                                const k = ymdKey(date);
                                setDragEndKey(k);
                                const keys = enumerateKeysInclusive(dragStartKey || k, k);
                                setDragPreviewKeys(new Set(keys));
                                if (dragStartKey && dragStartKey !== k) didDragRef.current = true;
                              }}
                              onMouseUp={() => {
                                if (isDraggingRange) endDragSelection();
                              }}
                              onClick={() => {
                                if (didDragRef.current) { didDragRef.current = false; return; }
                                setSelectedDate(date);
                                const k = ymdKey(date);
                                setSelectedRangeKeys([k]);
                                if (date.getMonth() !== viewMonth.getMonth() || date.getFullYear() !== viewMonth.getFullYear()) {
                                  setViewMonth(new Date(date.getFullYear(), date.getMonth(), 1));
                                }
                              }}
                            >
                              <span className="date-number">{date.getDate()}</span>
                              {hasSelection && <span className="date-marker" aria-hidden />}
                            </button>
                          );
                        })}
                      </div>
                    </div>
                    {(() => {
                      const key = ymdKey(selectedDate);
                      const blocks = daySelections[key] || [];
                      const handleBlocksChange = (next) => {
                        const targets = (selectedRangeKeys && selectedRangeKeys.length) ? selectedRangeKeys : [key];
                        setDaySelections((prev) => {
                          const patch = { ...prev };
                          for (const k of targets) patch[k] = next;
                          return patch;
                        });
                      };
                      return (
                        <ScheduleTimesPanel
                          value={formData.sessionDurationHours}
                          onChange={(next) => setFormData((prev) => ({ ...prev, sessionDurationHours: next }))}
                          listRef={timesListRef}
                          blocks={blocks}
                          onBlocksChange={handleBlocksChange}
                          dayKey={key}
                          getDayBlocks={getBlocksForDay}
                          setDayBlocks={setBlocksForDay}
                          applyKeys={(selectedRangeKeys && selectedRangeKeys.length) ? selectedRangeKeys : undefined}
                        />
                      );
                    })()}
                  </div>
                </div>
              ) : (
                <div className="step-illustration" aria-label="插图预留区域">
                  <div className="illustration-frame">
                    <Suspense fallback={<div />}> 
                      <DotLottiePlayer
                        src="/illustrations/Morphing.lottie"
                        autoplay
                        loop
                        style={{ width: '100%', height: '100%', background: 'transparent' }}
                      />
                    </Suspense>
                  </div>
                </div>
              )
            )}
          </section>

          <>
            {isUploadStep && !isDirectionSelectionStage && (
              <div className="contact-preview-floating" aria-label="导师页卡片预览">
                <div className="student-preview-card">
                  <div className="card-fav"><FaHeart /></div>
                  <div className="card-header">
                    <div className="avatar" aria-hidden="true">{previewName.slice(0,1).toUpperCase()}</div>
                    <div className="header-texts">
                      <div className="name">{previewName}</div>
                      <div className="chips">
                        <span className="chip green">{previewLevel}</span>
                        <span className="chip gray">{previewSchool}</span>
                      </div>
                    </div>
                  </div>
                  <div className="card-list" role="list">
                    <div className="item" role="listitem"><span className="icon"><FaGlobe /></span><span>{tzShort}（{tzCity || '时区'}）</span></div>
                    <div className="item" role="listitem"><span className="icon">{DIRECTION_ICONS[formData.courseDirection] || <FaFileAlt />}</span><span>{previewDirectionLabel}</span></div>
                    {!!previewCourseTypeLabel && (
                      <div className="item" role="listitem"><span className="icon"><FaGraduationCap /></span><span>课程类型：{previewCourseTypeLabel}</span></div>
                    )}
                    {hasTotalCourseHours && (
                      <div className="item" role="listitem"><span className="icon"><FaClock /></span><span>预计时长：{previewTotalCourseHours}小时</span></div>
                    )}
                    {!!(formData.courseFocus && formData.courseFocus.trim()) && (
                      <div className="item" role="listitem"><span className="icon"><FaLightbulb /></span><span>具体内容：{formData.courseFocus.trim()}</span></div>
                    )}
                    {!!(formData.milestone && formData.milestone.trim()) && (
                      <div className="item" role="listitem"><span className="icon"><FaTasks /></span><span>学习目标：{formData.milestone.trim()}</span></div>
                    )}
                    {earliestSelectedDay && (
                      <div className="item" role="listitem"><span className="icon"><FaCalendarAlt /></span><span>期望首课：{earliestSelectedDay}</span></div>
                    )}
                  </div>                
                </div>
              </div>
            )}

            <footer className={stepFooterClassName}>
              <div className="step-footer-shell">
                <div className="step-progress">
                  <div className="progress-track">
                    <div className="progress-bar" style={{ width: `${progress}%` }} />
                  </div>
                </div>
  
                <div className="step-actions">
                  <button type="button" className="ghost-button" onClick={handleBack} disabled={transitionStage !== 'idle'}>
                    返回
                  </button>
                  <button
                    type="button"
                    className="primary-button"
                    onClick={handleNext}
                    disabled={transitionStage !== 'idle'}
                  >
                    {currentStepIndex === STEPS.length - 1 ? '提交需求' : '下一步'}
                  </button>
                </div>
              </div>
            </footer>
          </>
        </div>
      </main>
    </div>
  );
}

export default StudentCourseRequestPage;




















